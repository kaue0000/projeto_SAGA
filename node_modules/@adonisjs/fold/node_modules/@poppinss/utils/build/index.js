import { n as safeParse, t as safeStringify } from "./main-_zxQ-frM.js";
import { n as naturalSort, t as isScriptFile } from "./is_script_file-CbSEfxE_.js";
import { r as RuntimeException } from "./exception-L7vjh-Gv.js";
import { flattie } from "flattie";
import { Buffer } from "node:buffer";
import { timingSafeEqual } from "node:crypto";
import string from "@poppinss/string";
import lodash from "@poppinss/utils/lodash";
const REDACTED = "[redacted]";
var Secret = class Secret {
	#value;
	#keyword;
	constructor(value, redactedKeyword) {
		this.#value = value;
		this.#keyword = redactedKeyword || REDACTED;
	}
	toJSON() {
		return this.#keyword;
	}
	valueOf() {
		return this.#keyword;
	}
	[Symbol.for("nodejs.util.inspect.custom")]() {
		return this.#keyword;
	}
	toLocaleString() {
		return this.#keyword;
	}
	toString() {
		return this.#keyword;
	}
	release() {
		return this.#value;
	}
	map(transformFunc) {
		return new Secret(transformFunc(this.#value));
	}
};
function compose(superclass, ...mixins) {
	return mixins.reduce((c, mixin) => mixin(c), superclass);
}
function flatten(input, glue, keepNullish) {
	return flattie(input, glue, keepNullish);
}
function safeEqual(trustedValue, userInput) {
	if (typeof trustedValue === "string" && typeof userInput === "string") {
		const trustedLength = Buffer.byteLength(trustedValue);
		const trustedValueBuffer = Buffer.alloc(trustedLength, 0, "utf-8");
		trustedValueBuffer.write(trustedValue);
		const userValueBuffer = Buffer.alloc(trustedLength, 0, "utf-8");
		userValueBuffer.write(userInput);
		return timingSafeEqual(trustedValueBuffer, userValueBuffer) && trustedLength === Buffer.byteLength(userInput);
	}
	return timingSafeEqual(Buffer.from(trustedValue), Buffer.from(userInput));
}
async function importDefault(importFn, filePath) {
	const moduleExports = await importFn();
	if (!("default" in moduleExports)) throw new RuntimeException(filePath ? `Missing "export default" in module "${filePath}"` : `Missing "export default" from lazy import "${importFn}"`, { cause: { source: importFn } });
	return moduleExports.default;
}
var MessageBuilder = class {
	#getExpiryDate(expiresIn) {
		if (!expiresIn) return;
		const expiryMs = string.milliseconds.parse(expiresIn);
		return new Date(Date.now() + expiryMs);
	}
	#isExpired(message) {
		if (!message.expiryDate) return false;
		const expiryDate = new Date(message.expiryDate);
		return Number.isNaN(expiryDate.getTime()) || expiryDate < /* @__PURE__ */ new Date();
	}
	build(message, expiresIn, purpose) {
		return safeStringify({
			message,
			purpose,
			expiryDate: this.#getExpiryDate(expiresIn)
		});
	}
	verify(message, purpose) {
		const parsed = safeParse(message);
		if (typeof parsed !== "object" || !parsed) return null;
		if (!parsed.message) return null;
		if (parsed.purpose !== purpose) return null;
		if (this.#isExpired(parsed)) return null;
		return parsed.message;
	}
};
function defineStaticProperty(self, propertyName, { initialValue, strategy }) {
	if (!self.hasOwnProperty(propertyName)) {
		const value = self[propertyName];
		if (strategy === "define" || value === void 0) {
			Object.defineProperty(self, propertyName, {
				value: initialValue,
				configurable: true,
				enumerable: true,
				writable: true
			});
			return;
		}
		Object.defineProperty(self, propertyName, {
			value: typeof strategy === "function" ? strategy(value) : lodash.cloneDeep(value),
			configurable: true,
			enumerable: true,
			writable: true
		});
	}
}
export { MessageBuilder, Secret, compose, defineStaticProperty, flatten, importDefault, isScriptFile, naturalSort, safeEqual };
